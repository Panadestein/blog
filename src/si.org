# -*- eval: (face-remap-add-relative 'default '(:family "BQN386 Unicode" :height 180)); -*-
#+TITLE: Scheming a mise-en-abÃ®me in BQN
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="assets/style.css"/>
#+HTML_HEAD: <link rel="icon" href="assets/favicon.ico" type="image/x-icon">

** Prelude

We will build an interpreter for a subset of the Scheme programming language,
following an [[https://www.norvig.com/lispy.html][essay]] by Peter Norvig. An alternative reference would
have been of course SICP's metacircular evaluator[fn:1], but I consider =lispy= to be
a very elegant implementation targeting a non-Lisp host[fn:2]. Please beware this
post is a learning exercise. Most of what I know about
language implementation comes from self-study of a handful of books[fn:3].

** A R5RS dialect

Our goal is to adhere to the Revised\(^5\) Report on the Algorithmic Language Scheme ([[https://conservatory.scheme.org/schemers/Documents/Standards/R5RS/HTML/r5rs.html][R5RS]]).
However, seasoned schemers will quickly notice that our implementation still has
quite some distance to cover in reaching full compliance.

Let's start by defining some utilities. One aspect I don't like about Scheme is that it uses
special values for Booleans, so we  [[https://mlochbaum.github.io/BQN/tutorial/combinator.html#booleans][unfortunately]]  need the 1-modifier. The function, on the other hand,
is a fine example of the minimalistic OOP features BQN provides. It is used to create a class
for the environment used in the Scheme interpreter.

#+begin_src bqn :tangle ./bqn/si.bqn
  _bool â† {ð”½â—¶"#f"â€¿"#t"}
  C â† {ð•¨ð•Špâ€¿v:
    oâ€¿h â‡ ð•¨ â‹ˆ p â€¢HashMap v
    F â‡ {h.Has ð•© ? h; @â‰¢o ? o.F ð•©; 0}
  }
#+end_src

#+RESULTS:
: (function block)

We then define a global environment that serves as the base for the interpreter. Here,
we leverage BQN primitives and system values, and in some specific cases, we define additional functions.

#+begin_src bqn :tangle ./bqn/si.bqn
  env â† @ C âŸ¨
    "sin", "cos", "tan", "asin", "acos", "atan"
    "log", "+", "-", "*", "/", ">", "<", ">=", "<=", "="
    "abs", "append", "apply", "begin", "car", "cdr", "cons"
    "eq?", "expt", "equal?", "length", "list", "list?"
    "map", "max", "min", "not", "null?", "number?"
    "print", "round", "symbol?", "nil", "pi"
  âŸ© â‹ˆ âŸ¨
    â‹†â¼, +Â´, -Â´, Ã—Â´, Ã·Â´, >Â´, <Â´, â‰¥Â´, â‰¤Â´, =Â´
    |, âˆ¾Â´, {ð•Žð•©}Â´, {ð•©}, âŠ‘, 1âŠ¸â†“, âˆ¾Â´
    â‰¡Â´_bool, â‹†Â´, =Â´_bool, â‰ , â‹ˆÂ´, 0âŠ¸=_bool{â€¢Typeâ€¢BQNâŽŠ1ð•©}
    {ð•Žâˆ˜â‹ˆÂ¨ð•©}Â´, âŒˆÂ´, âŒŠÂ´, 0âŠ¸â‰ _boolÂ¬, @âŠ¸=_bool, (1âŠ£â€¢ParseFloat)âŽŠ0 _bool
    â€¢Show, âŒŠ0.5+âŠ¢, 2âŠ¸=_bool{â€¢TypeâŠ‘ð•©}, @, Ï€
  âŸ© âˆ¾Ëœ â€¢math â€¢ns.GetÂ¨ "sin"â€¿"cos"â€¿"tan"â€¿"asin"â€¿"acos"â€¿"atan"
#+end_src

#+RESULTS:
: {oâ€¿hâ€¿fâ‡}

The interpreter is defined as a 1-modifier so we can create a function using different base environments:

#+begin_src bqn :tangle ./bqn/si.bqn
  _sch â† {
    T â† (âŠ¢/ËœÂ·âˆ¨Â´Â¨' 'âŠ¸â‰ )Â·(-âŸœ1Â·+`Â·Â¬âŠ¸âˆ§âŸœÂ»âŠ¸âˆ¨Â·+Ë"( )"=âŒœâŠ¢)âŠ¸âŠ”(âŠ¢+22Ã—@=10-ËœâŠ¢)
    R â† {
      ð•ŠâŸ¨âŸ©: "Empty program"!0;
      ð•Šð•©: {
        "("â‰¡âŠ‘ð•¨ ? lâ†âŸ¨âŸ© â‹„ lâ‹ˆ1â†“{tâ€¿ts: tsâŠ£lâˆ¾â†©<t}âˆ˜Râ€¢_while_(")"â‰¢âŠ‘) ð•©;
        ")"â‰¡âŠ‘ð•¨ ? "Unexpected )"!0 ;
        ð•© â‹ˆËœ â€¢ParseFloatâŽŠâŠ¢ âŠ‘ð•¨
      }Â´ 1(â†‘â‹ˆâ†“)ð•©
    }
    E â† {
      0â‰ ð•¨.F ð•© ? (ð•¨.F ð•©).Get ð•©;
      1=â€¢TypeâŠ‘âŸ¨ð•©âŸ© ? ð•©;
      "quote"â‰¡âŠ‘ð•© ? Â·â€¿arg â† ð•© â‹„ arg;
      "if"â‰¡âŠ‘ð•© ? Â·â€¿tstâ€¿cndâ€¿alt â† ð•© â‹„ ð•¨(âŠ£ð•Šð•Šâ—¶altâ€¿cnd)tst;
      "define"â‰¡âŠ‘ð•© ? Â·â€¿varâ€¿val â† ð•© â‹„ âŸ¨âŸ© âŠ£ var ð•¨.h.Set ð•¨ð•Šval;
      "lambda"â‰¡âŠ‘ð•© ? Â·â€¿parâ€¿bod â† ð•© â‹„ ð•¨{bod EËœ ð•— C parâ€¿ð•©};
      f â† ð•¨ð•ŠâŠ‘ð•© â‹„ F ð•¨âŠ¸ð•ŠÂ¨1â†“ð•© 
    }
    P â† (âŠ¢+Ë("(   )"-"âŸ¨"",â€¿âŸ©")Ã—"âŸ¨"",â€¿âŸ©"=âŒœâŠ¢)âˆ˜â€¢ReprÂ·1âŠ¸=âˆ˜â‰ â—¶âŠ¢â€¿âŠ‘(0<â‰ Â¨)âŠ¸/âŽŠâŠ¢
    P ð•—âŠ¸EâŠ‘Râˆ˜T ð•©
  }
#+end_src

#+RESULTS:
: (1-modifier block)

And now for the climax. Our interpreter inherits all the limitations from the one in the reference essay,
the most critical being the lack of proper error handling. Additionally,
as the names of the functions inside the modifier suggest, the =L= is missing in =Read â†’ Eval â†’ Print=.
In terms of golfing statistics, =lispy= has 117 non-comment non-blank lines, whereas =Scheme= has only 42.

#+begin_src bqn :tangle ./bqn/si.bqn
  Scheme â† env _sch
#+end_src

#+RESULTS:
: {oâ€¿hâ€¿fâ‡}(1-modifier block)

** A Lisp quine

Given the title of this post, it's only fitting that we test our interpreter with a quine. In fact, building this interpreter
was, for me, an exercise in bootstrapping the necessary machinery to produce this recursive effect:

#+begin_src bqn :tangle ./bqn/si.bqn :exports both
  Scheme "((lambda (x) (list x (list (quote quote) x)))
           (quote (lambda (x) (list x (list (quote quote) x)))))"
#+end_src

#+RESULTS:
: "(( lambda  ( x ) ( list   x  ( list  ( quote   quote )  x ))) ( quote  ( lambda  ( x ) ( list   x  ( list  ( quote   quote )  x )))))"

Naturally, we can do more rigorous tests by comparing to my favorite Scheme
implementation[fn:4]. To achieve this, we'll leverage BQN's
foreign function interface:

#+begin_src bqn :tangle ./bqn/si.bqn
  ch â† "../supp/chicken/libchicken.so" â€¢FFI "*u8"â€¿"eval_scheme"â€¿">*u8:c8"
  R5RS â† {@+ð•©.ReadÂ¨ â†•1âŠ¸+â€¢_while_(0â‰ ð•©.Read)0}Ch
#+end_src

#+RESULTS:
: (function block)(foreign function)

But fear not, thereâ€™s no room for monotony here. After all,
people much prefer dealing with machinery to dealing with bureaucracies[fn:5]:

#+begin_src bqn :tangle ./bqn/si.bqn :exports both
  (Schemeâ‹ˆR5RS)Â¨ âŸ¨
    "(+ 10 122)"
    "(* 4 2)"
    "(begin (define r 10) (+ (/ 4 2) (* r r)))"
    "(symbol? a)"
    "(number? 333)"
    "(if (> (* 11 11) 120) (* 7 6) oops)"
    "(begin
       (define fib (lambda (n) (if (< n 2) 1 (+ (fib (- n 1)) (fib (- n 2))))))
       (define range (lambda (a b) (if (= a b) (quote ()) (cons a (range (+ a 1) b)))))
       (map fib (range 0 10)))"
  âŸ©
#+end_src

#+RESULTS:
: âŸ¨ âŸ¨ "132" "132" âŸ© âŸ¨ "8" "8" âŸ© âŸ¨ "102" "102" âŸ© âŸ¨ " #f " "#f" âŸ© âŸ¨ " #t " "#t" âŸ© âŸ¨ "42" "42" âŸ© âŸ¨ "1 1 2 3 5 8 13 21 34 55" "(1 1 2 3 5 8 13 21 34 55)" âŸ© âŸ©

If you manage to find any sneaky corner cases that break the interpreter in the given subset, let me know!
And please forgive the formatting problems, I'm tired of fiddling with the printer at this point.

[fn:1] I recommend SICP as further reading. Much like Louis Reasoner, I attempted
solving all the problems in the book, but I haven't gotten very far.
I believe there are some interesting Racket bits in my [[https://panadestein.github.io/solved-sicp/][solutions]], though.
[fn:2] I am not alone in this view; for instance, the [[https://www.fluentpython.com/][Lizard Book]] dedicates
an entire section to it.
[fn:3] In addition to the great SICP, I also studied from [[https://craftinginterpreters.com][Crafting Interpreters]] and
[[https://www3.nd.edu/~dthain/compilerbook/][Introduction to Compilers and Language Design]].
[fn:4] One of my favorite hacker guidelines is [[http://www.call-with-current-continuation.org/articles/brutalist-manifesto.txt][The Brutalist Programming Manifesto]],
written by the creator of Chicken Scheme.
[fn:5] John McCarthy, [[http://jmc.stanford.edu/general/sayings.html][1986]].

#+BEGIN_EXPORT html
  <div style="text-align: center; font-size: 2em; padding: 20px 0;">
    <a href="https://panadestein.github.io/blog/" style="text-decoration: none;">âŠ‘âˆ˜âˆž</a>
  </div>
#+END_EXPORT
