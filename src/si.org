# -*- eval: (face-remap-add-relative 'default '(:family "BQN386 Unicode" :height 180)); -*-
#+TITLE: Scheming a mise-en-abÃ®me in BQN
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="assets/style.css"/>
#+HTML_HEAD: <link rel="icon" href="assets/favicon.ico" type="image/x-icon">

** Prelude

We will build an interpreter for a subset of the Scheme programming language,
following an [[https://www.norvig.com/lispy.html][essay]] by Peter Norvig. An alternative reference would
have been of course SICP's metacircular evaluator[fn:1], but I consider =lispy= to be
a very elegant implementation targeting a non-Lisp host[fn:2].

/Achtung/: this post is a learning exercise. Most of what I know about
language implementation comes from self-study of a handful of books[fn:3]
and blogs like Norvig's.

** A R5RS dialect

Our goal is to adhere to the Revised\(^5\) Report on the Algorithmic Language Scheme ([[https://conservatory.scheme.org/schemers/Documents/Standards/R5RS/HTML/r5rs.html][R5RS]]).
However, seasoned schemers will quickly notice that our implementation still has
quite some distance to cover in reaching full compliance. Let's start by defining some
utilities. It is unfortunate that the 1-modifier is required,
given that Booleans are not that [[https://mlochbaum.github.io/BQN/tutorial/combinator.html#booleans][special]].

#+begin_src bqn :tangle ./bqn/si.bqn :results none
  _bool â† {ð”½â—¶"#f"â€¿"#t"}
#+end_src

A global environment:

#+begin_src bqn :tangle ./bqn/si.bqn
  env â† âŸ¨
    "sin", "cos", "tan", "asin", "acos", "atan"
    "log", "+", "-", "*", "/", ">", "<", ">=", "<=", "="
    "abs", "append", "apply", "begin", "car", "cdr", "cons"
    "eq?", "expt", "equal?", "length", "list", "list?"
    "map", "max", "min", "not", "null?", "number?"
    "print", "round", "symbol?", "nil", "pi"
  âŸ© â€¢HashMap âŸ¨
    â‹†â¼, +Â´, -Â´, Ã—Â´, Ã·Â´, >Â´, <Â´, â‰¥Â´, â‰¤Â´, =Â´
    |, âˆ¾Â´, {ð•Žð•©}Â´, {ð•©}, âŠ‘, 1âŠ¸â†“, â‹ˆÂ´
    â‰¡Â´_bool, â‹†Â´, =Â´_bool, â‰ , â‹ˆ, 0âŠ¸=_bool{â€¢Typeâ€¢BQNâŽŠ1ð•©}
    {ð•ŽÂ¨ð•©}Â´, âŒˆÂ´, âŒŠÂ´, 0âŠ¸â‰ _boolÂ¬, @âŠ¸=_bool, â€¢BQNâŽŠ1
    â€¢Show, âŒŠ0.5+âŠ¢, 2âŠ¸=_bool{â€¢TypeâŠ‘ð•©}, @, Ï€
  âŸ© âˆ¾Ëœ â€¢math â€¢ns.GetÂ¨ "sin"â€¿"cos"â€¿"tan"â€¿"asin"â€¿"acos"â€¿"atan"
#+end_src

#+RESULTS:
: {getâ€¿hasâ€¿setâ€¿deleteâ€¿countâ€¿keysâ€¿valuesâ‡}

The interpreter:

#+begin_src bqn :tangle ./bqn/si.bqn
  Scheme â† {
    T â† (âŠ¢/ËœÂ·âˆ¨Â´Â¨' 'âŠ¸â‰ )(-âŸœ1Â·+`Â·Â¬âŠ¸âˆ§âŸœÂ»âŠ¸âˆ¨Â·+Ë"( )"=âŒœâŠ¢)âŠ¸âŠ”
    R â† {
      ð•ŠâŸ¨âŸ©: "Empty program"!0;
      ð•Šð•©: {
        "("â‰¡âŠ‘ð•¨ ? lâ†âŸ¨âŸ© â‹„ lâ‹ˆ1â†“{tâ€¿ts: tsâŠ£lâˆ¾â†©<t}âˆ˜Râ€¢_while_(")"â‰¢âŠ‘) ð•©;
        ")"â‰¡âŠ‘ð•¨ ? "Unexpected )"!0 ;
        ð•© â‹ˆËœ â€¢ParseFloatâŽŠâŠ¢ âŠ‘ð•¨
      }Â´ 1(â†‘â‹ˆâ†“)ð•©
    }
    E â† {
      env.Has ð•© ? env.Get ð•©;
      1=â€¢TypeâŠ‘âŸ¨ð•©âŸ© ? ð•©;
      "if"â‰¡âŠ‘ð•© ? Â·â€¿tstâ€¿cndâ€¿alt â† ð•© â‹„ env(âŠ£ð•Šð•Šâ—¶altâ€¿cnd)tst;
      "define"â‰¡âŠ‘ð•© ? Â·â€¿varâ€¿val â† ð•© â‹„ âŸ¨âŸ© âŠ£ var env.Set envð•Šval;
      f â† envð•ŠâŠ‘ð•© â‹„ F envâŠ¸ð•ŠÂ¨1â†“ð•© 
    }
    P â† (âŠ¢+Ë("()"-"âŸ¨âŸ©")Ã—"âŸ¨âŸ©"=âŒœâŠ¢)âˆ˜â€¢FmtÂ·1âŠ¸=âˆ˜â‰ â—¶âŠ¢â€¿âŠ‘âˆ¾âŽŠâŠ¢
    P envâŠ¸EâŠ‘Râˆ˜T ð•©
  }
#+end_src

#+RESULTS:
: (function block)

** A Lisp quine

Given the title of this post, it seems only fitting to test our interpreter
with a quine:

#+begin_src bqn :tangle ./bqn/si.bqn :exports both
  Scheme "((lambda (x) (list x (list (quote quote) x)))
           (quote (lambda (x) (list x (list (quote quote) x)))))"
#+end_src

#+RESULTS:
#+begin_example
Error: Stack overflow
at     "define"â‰¡âŠ‘ð•© ? Â·â€¿varâ€¿val â† ð•© â‹„ âŸ¨âŸ© âŠ£ var env.Set envð•Šval;
                   ^
at     "if"â‰¡âŠ‘ð•© ? Â·â€¿tstâ€¿cndâ€¿alt â† ð•© â‹„ env(âŠ£ð•Šð•Šâ—¶altâ€¿cnd)tst;
               ^
at     1=â€¢TypeâŠ‘âŸ¨ð•©âŸ© ? ð•©;
                   ^
at     env.Has ð•© ? env.Get ð•©;
                 ^
at     f â† envð•ŠâŠ‘ð•© â‹„ F envâŠ¸ð•ŠÂ¨1â†“ð•© 
              ^
at     "define"â‰¡âŠ‘ð•© ? Â·â€¿varâ€¿val â† ð•© â‹„ âŸ¨âŸ© âŠ£ var env.Set envð•Šval;
                   ^
at     "if"â‰¡âŠ‘ð•© ? Â·â€¿tstâ€¿cndâ€¿alt â† ð•© â‹„ env(âŠ£ð•Šð•Šâ—¶altâ€¿cnd)tst;
               ^
at     1=â€¢TypeâŠ‘âŸ¨ð•©âŸ© ? ð•©;
                   ^
at     env.Has ð•© ? env.Get ð•©;
                 ^
(4076 entries omitted)
at     f â† envð•ŠâŠ‘ð•© â‹„ F envâŠ¸ð•ŠÂ¨1â†“ð•©
#+end_example

Naturally, we can do more rigorous tests by comparing to my favorite Scheme
implementation[fn:4]. To achieve this, we'll leverage BQN's
foreign function interface:

#+begin_src bqn :tangle ./bqn/si.bqn :results none
  ch â† "../supp/chicken/libchicken.so" â€¢FFI "*u8"â€¿"eval_scheme"â€¿">*u8:c8"
  R5RS â† {@+ð•©.ReadÂ¨ â†•1âŠ¸+â€¢_while_(0â‰ ð•©.Read)0}Ch
#+end_src

But fear not, thereâ€™s no room for monotony here. After all,
people much prefer dealing with machinery to dealing with bureaucracies[fn:5]:

#+begin_src bqn :tangle ./bqn/si.bqn :exports both
  ("Not Compliant"âŠ¸!Schemeâ‰¡R5RS)Â¨ âŸ¨
    "(+ 10 122)"
    "(* 4 2)"
    "(begin (define r 10) (+ (/ 4 2) (* r r)))"
    "(if (> (* 11 11) 120) (* 7 6) oops)"
  âŸ©
#+end_src

#+RESULTS:
: âŸ¨ 1 1 1 1 âŸ©

If you manage to find any sneaky corner cases (modulo formatting, if you are comparing with Chicken)
that break the interpreter, do let me know!

[fn:1] I recommend SICP as further reading. Much like Louis Reasoner, I attempted
solving all the problems in the book, but I haven't gotten very far.
I believe there are some interesting Racket bits in my [[https://panadestein.github.io/solved-sicp/][solutions]], though.
[fn:2] I am not alone in this view; for instance, the [[https://www.fluentpython.com/][Lizard Book]] dedicates
an entire section to it.
[fn:3] For instance [[https://craftinginterpreters.com][Crafting Interpreters]] and [[https://www3.nd.edu/~dthain/compilerbook/][Introduction to Compilers and Language Design]].
[fn:4] One of my favorite hacker guidelines is [[http://www.call-with-current-continuation.org/articles/brutalist-manifesto.txt][The Brutalist Programming Manifesto]],
written by the creator of Chicken Scheme.
[fn:5] John McCarthy, [[http://jmc.stanford.edu/general/sayings.html][1986]].

#+BEGIN_EXPORT html
  <div style="text-align: center; font-size: 2em; padding: 20px 0;">
    <a href="https://panadestein.github.io/blog/" style="text-decoration: none;">âŠ‘âˆ˜âˆž</a>
  </div>
#+END_EXPORT
