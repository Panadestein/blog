# -*- eval: (face-remap-add-relative 'default '(:family "BQN386 Unicode" :height 180)); -*-
#+TITLE: A coding impromptu 
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="assets/style.css"/>
#+HTML_HEAD: <script>
#+HTML_HEAD:   function goBack() {
#+HTML_HEAD:     window.history.back();
#+HTML_HEAD:   }
#+HTML_HEAD: </script>
#+HTML_HEAD: <link rel="icon" href="assets/favicon.ico" type="image/x-icon">

A rolling collection of algorithms I like, implemented in BQN.

** Z algorithm

This is a very efficient procedure that finds prefix strings in [[https://cp-algorithms.com/string/z-function.html][linear time]]. The imperative
implementation reads:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  ZI â† {
    lâ€¿râ€¿z â† 0â€¿0â€¿(0Â¨ğ•©)
    {z âŠËœâŒ¾(r<â—¶(r-ğ•©+1âŒŠzâŠËœğ•©-l)â€¿0)ğ•©}Â¨ â†•â‰ ğ•©
  }
  ZI "abacabadabacaba"
#+end_src

#+RESULTS:
: Error: Second-level parts of a train must be functions
: at   {z âŠËœâŒ¾(r<â—¶(r-ğ•©+1âŒŠzâŠËœğ•©-l)â€¿0)ğ•©}Â¨ â†•â‰ ğ•©
:             ^

#+begin_src cpp
  int x = 0, y = 0;
  for (int i = 1; i < n; i++) {
    z[i] = (y < i) ? 0 : min(y-i+1,z[i-x]);
    while (i+z[i] < n && s[z[i]] == s[i+z[i]]) z[i]++;
    if (i+z[i]-1 > y) {
      x = i; y = i+z[i]-1;
    }
  }
#+end_src

And the array version:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  ZA â† 1
  ZA "abacabadabacaba"
#+end_src

** Longest increasing sub-sequence

This [[https://en.wikipedia.org/wiki/Longest_increasing_subsequence][problem]] can be solved in \(O(n\log n)\) using dynamic programming. Here is an
imperative implementation which is quadratic, but can be optimized:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  LISI â† {
    kâ€¿dp â† Â¯1â€¿(âˆÂ¨ğ•©)
    {i â† âˆ§Â´â—¶(âŠ‘âŠâŸœ0)â€¿{ğ•Š:k+â†©1} dp<ğ•© â‹„ dp ğ•©âŒ¾(iâŠ¸âŠ‘)â†©}Â¨ ğ•©
    +Â´âˆ>dp
  }
  LISIÂ¨ âŸ¨0â€¿1â€¿0â€¿3â€¿2â€¿3, 10â€¿9â€¿2â€¿5â€¿3â€¿7â€¿101â€¿18, 7â€¿7â€¿7â€¿7â€¿7âŸ©
#+end_src

#+RESULTS:
: âŸ¨ 4 4 1 âŸ©

A more elegant array and tacit solution was crafted by Dzaima and Marshall:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  LISA â† +Â´âˆâ‰ âˆÂ¨{ğ•¨âŒ¾((âŠ‘ğ•©â‹ğ•¨-1)âŠ¸âŠ‘)ğ•©}Â´âŒ½
  LISAÂ¨ âŸ¨0â€¿1â€¿0â€¿3â€¿2â€¿3, 10â€¿9â€¿2â€¿5â€¿3â€¿7â€¿101â€¿18, 7â€¿7â€¿7â€¿7â€¿7âŸ©
#+end_src

#+RESULTS:
: âŸ¨ 4 4 1 âŸ©

In case you are wondering like I did, the minus one there is to make the bins comparison
strictly increasing.

** N-queens problem

This problem is the archetypal example of backtracking. Initially, I tried to solve it
using a function to place the queens in the full board, hoping that it would lead to a
more array oriented solution:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  8 {nğ•Šiâ€¿j: ((âˆ¨âŒœÂ´0âŠ¸=)âˆ¨(0=-âŒœÂ´)âˆ¨0=+âŒœÂ´) jâ€¿i-Â¨<â†•n} 2â€¿3
#+end_src

#+RESULTS:
#+begin_example
â”Œâ”€                 
â•µ 0 0 1 0 0 1 0 0  
  1 0 1 0 1 0 0 0  
  0 1 1 1 0 0 0 0  
  1 1 1 1 1 1 1 1  
  0 1 1 1 0 0 0 0  
  1 0 1 0 1 0 0 0  
  0 0 1 0 0 1 0 0  
  0 0 1 0 0 0 1 0  
                  â”˜
#+end_example

This resulted in a more complicated algorithm, so I decided to go for the classical
Wirth implementation:

#+begin_src bqn :tangle ./bqn/rollim.bqn :results none
  NQ â† {ğ•Šn:
    Vâ€¿P â† {âŠ£ğ•(âŠ¢âˆ¾-â‹ˆ+)Â´âˆ˜âŠ¢}Â¨ âŸ¨âˆ¨Â´âŠ‘Â¨Ëœ, {1âŒ¾(ğ•©âŠ¸âŠ‘)ğ•¨}Â¨âŸ©
    {nâ‰ ğ•© ? +Â´(ğ•¨VâŠ¢)â—¶âŸ¨(ğ•©+1)ğ•ŠËœğ•¨PâŠ¢,0âŸ©âˆ˜(ğ•©â‹ˆâŠ¢)Â¨ â†•n ; 1
    }ËœÂ´ (0â‹ˆ0Ã—Â·â†•Â¨âŠ¢âˆ¾Â·â‹ˆËœ+Ëœ)n 
  }
#+end_src

Which nicely compares with the OEIS [[https://oeis.org/A000170][sequence]]:

#+begin_src bqn :tangle ./bqn/rollim.bqn 
  a000170 â† 1â€¿0â€¿0â€¿2â€¿10â€¿4â€¿40â€¿92
  a000170 â‰¡ NQÂ¨ 1+â†•8
#+end_src

#+RESULTS:
: 1

#+BEGIN_EXPORT html
  <div style="text-align: center; font-size: 2em; padding: 20px 0;">
    <a href="#" onclick="goBack(); return false;">âŠ‘âˆ˜âˆ</a>
  </div>
#+END_EXPORT
