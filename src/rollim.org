# -*- eval: (face-remap-add-relative 'default '(:family "BQN386 Unicode" :height 180)); -*-
#+TITLE: A coding impromptu 
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="assets/style.css"/>
#+HTML_HEAD: <script>
#+HTML_HEAD:   function goBack() {
#+HTML_HEAD:     window.history.back();
#+HTML_HEAD:   }
#+HTML_HEAD: </script>
#+HTML_HEAD: <link rel="icon" href="assets/favicon.ico" type="image/x-icon">

A rolling collection of algorithms I like, implemented in BQN.

** Z algorithm

This is a very efficient procedure that finds prefix strings in [[https://cp-algorithms.com/string/z-function.html][linear time]]. The imperative
implementation reads:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  ZI ← {
    l‿r‿z ← 0‿0‿(0¨𝕩)
    {z ⊏˜⌾(r<◶(r-𝕩+1⌊z⊏˜𝕩-l)‿0)𝕩}¨ ↕≠𝕩
  }
  ZI "abacabadabacaba"
#+end_src

#+RESULTS:
: Error: Second-level parts of a train must be functions
: at   {z ⊏˜⌾(r<◶(r-𝕩+1⌊z⊏˜𝕩-l)‿0)𝕩}¨ ↕≠𝕩
:             ^

#+begin_src cpp
  int x = 0, y = 0;
  for (int i = 1; i < n; i++) {
    z[i] = (y < i) ? 0 : min(y-i+1,z[i-x]);
    while (i+z[i] < n && s[z[i]] == s[i+z[i]]) z[i]++;
    if (i+z[i]-1 > y) {
      x = i; y = i+z[i]-1;
    }
  }
#+end_src

And the array version:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  ZA ← 1
  ZA "abacabadabacaba"
#+end_src

** Longest increasing sub-sequence

This [[https://en.wikipedia.org/wiki/Longest_increasing_subsequence][problem]] can be solved in \(O(n\log n)\) using dynamic programming. Here is an
imperative implementation which is quadratic, but can be optimized:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  LISI ← {
    k‿dp ← ¯1‿(∞¨𝕩)
    {i ← ∧´◶(⊑⊐⟜0)‿{𝕊:k+↩1} dp<𝕩 ⋄ dp 𝕩⌾(i⊸⊑)↩}¨ 𝕩
    +´∞>dp
  }
  LISI¨ ⟨0‿1‿0‿3‿2‿3, 10‿9‿2‿5‿3‿7‿101‿18, 7‿7‿7‿7‿7⟩
#+end_src

#+RESULTS:
: ⟨ 4 4 1 ⟩

A more elegant array and tacit solution was crafted by Dzaima and Marshall:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  LISA ← +´∞≠∞¨{𝕨⌾((⊑𝕩⍋𝕨-1)⊸⊑)𝕩}´⌽
  LISA¨ ⟨0‿1‿0‿3‿2‿3, 10‿9‿2‿5‿3‿7‿101‿18, 7‿7‿7‿7‿7⟩
#+end_src

#+RESULTS:
: ⟨ 4 4 1 ⟩

In case you are wondering like I did, the minus one there is to make the bins comparison
strictly increasing.

** N-queens problem

This problem is the archetypal example of backtracking. Initially, I tried to solve it
using a function to place the queens in the full board, hoping that it would lead to a
more array oriented solution:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  8 {n𝕊i‿j: ((∨⌜´0⊸=)∨(0=-⌜´)∨0=+⌜´) j‿i-¨<↕n} 2‿3
#+end_src

#+RESULTS:
#+begin_example
┌─                 
╵ 0 0 1 0 0 1 0 0  
  1 0 1 0 1 0 0 0  
  0 1 1 1 0 0 0 0  
  1 1 1 1 1 1 1 1  
  0 1 1 1 0 0 0 0  
  1 0 1 0 1 0 0 0  
  0 0 1 0 0 1 0 0  
  0 0 1 0 0 0 1 0  
                  ┘
#+end_example

This resulted in a more complicated algorithm, so I decided to go for the classical
Wirth implementation:

#+begin_src bqn :tangle ./bqn/rollim.bqn :results none
  NQ ← {𝕊n:
    V‿P ← {⊣𝕏(⊢∾-⋈+)´∘⊢}¨ ⟨∨´⊑¨˜, {1⌾(𝕩⊸⊑)𝕨}¨⟩
    {n≠𝕩 ? +´(𝕨V⊢)◶⟨(𝕩+1)𝕊˜𝕨P⊢,0⟩∘(𝕩⋈⊢)¨ ↕n ; 1
    }˜´ (0⋈0×·↕¨⊢∾·⋈˜+˜)n 
  }
#+end_src

Which nicely compares with the OEIS [[https://oeis.org/A000170][sequence]]:

#+begin_src bqn :tangle ./bqn/rollim.bqn 
  a000170 ← 1‿0‿0‿2‿10‿4‿40‿92
  a000170 ≡ NQ¨ 1+↕8
#+end_src

#+RESULTS:
: 1

#+BEGIN_EXPORT html
  <div style="text-align: center; font-size: 2em; padding: 20px 0;">
    <a href="#" onclick="goBack(); return false;">⊑∘∞</a>
  </div>
#+END_EXPORT
