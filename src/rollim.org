# -*- eval: (face-remap-add-relative 'default '(:family "BQN386 Unicode" :height 180)); -*-
#+TITLE: A coding impromptu 
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="assets/style.css"/>
#+HTML_HEAD: <script>
#+HTML_HEAD:   function goBack() {
#+HTML_HEAD:     window.history.back();
#+HTML_HEAD:   }
#+HTML_HEAD: </script>
#+HTML_HEAD: <link rel="icon" href="assets/favicon.ico" type="image/x-icon">

A rolling collection of algorithms I like, implemented in BQN.

** Z algorithm

This is a very efficient procedure that finds prefix strings in [[https://cp-algorithms.com/string/z-function.html][linear time]]. The imperative
implementation reads:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  ZI â† {
    lâ€¿râ€¿z â† 0â€¿0â€¿(0Â¨ğ•©)
    {z âŠËœâŒ¾(r<â—¶(r-ğ•©+1âŒŠzâŠËœğ•©-l)â€¿0)ğ•©}Â¨ â†•â‰ ğ•©
  }
  ZI "abacabadabacaba"
#+end_src

#+RESULTS:
: Error: Second-level parts of a train must be functions
: at   {z âŠËœâŒ¾(r<â—¶(r-ğ•©+1âŒŠzâŠËœğ•©-l)â€¿0)ğ•©}Â¨ â†•â‰ ğ•©
:             ^

#+begin_src cpp
  int x = 0, y = 0;
  for (int i = 1; i < n; i++) {
    z[i] = (y < i) ? 0 : min(y-i+1,z[i-x]);
    while (i+z[i] < n && s[z[i]] == s[i+z[i]]) z[i]++;
    if (i+z[i]-1 > y) {
      x = i; y = i+z[i]-1;
    }
  }
#+end_src

And the array version:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  ZA â† 1
  ZA "abacabadabacaba"
#+end_src

** Longest increasing sub-sequence

This [[https://en.wikipedia.org/wiki/Longest_increasing_subsequence][problem]] can be solved in \(O(n\log n)\) using dynamic programming. Here is an
imperative implementation which is quadratic, but can be optimized:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  LI â† {
    kâ€¿dp â† Â¯1â€¿(âˆÂ¨ğ•©)
    {i â† âˆ§Â´â—¶(âŠ‘âŠâŸœ0)â€¿{ğ•Š:k+â†©1} dp<ğ•© â‹„ dp ğ•©âŒ¾(iâŠ¸âŠ‘)â†©}Â¨ ğ•©
    +Â´âˆ>dp
  }
  LIÂ¨ âŸ¨0â€¿1â€¿0â€¿3â€¿2â€¿3, 10â€¿9â€¿2â€¿5â€¿3â€¿7â€¿101â€¿18, 7â€¿7â€¿7â€¿7â€¿7âŸ©
#+end_src

#+RESULTS:
: âŸ¨ 4 4 1 âŸ©

A more elegant tacit solution was crafted by Dzaima and Marshall:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  LA â† +Â´âˆâ‰ âˆÂ¨{ğ•¨âŒ¾((âŠ‘ğ•©â‹ğ•¨-1)âŠ¸âŠ‘)ğ•©}Â´âŒ½
  LAÂ¨ âŸ¨0â€¿1â€¿0â€¿3â€¿2â€¿3, 10â€¿9â€¿2â€¿5â€¿3â€¿7â€¿101â€¿18, 7â€¿7â€¿7â€¿7â€¿7âŸ©
#+end_src

#+RESULTS:
: âŸ¨ 4 4 1 âŸ©

In case you are wondering like I did, the minus one is there to make the bins comparison
strictly increasing.

** N-queens problem

This problem is archetypal example of backtracking:

#+begin_src bqn :tangle ./bqn/rollim.bqn
  NQ â† {
    +â€¿-â€¿âŠ¢ {ğ•âŒœâ—‹â†•Ëœğ•©}Â¨ ğ•©
  }
  NQ 8
#+end_src

#+RESULTS:
#+begin_example
â”Œâ”€                                                                         
Â· â”Œâ”€                       â”Œâ”€                         â”Œâ”€                   
  â•µ 0 1 2  3  4  5  6  7   â•µ 0 Â¯1 Â¯2 Â¯3 Â¯4 Â¯5 Â¯6 Â¯7   â•µ 0 1 2 3 4 5 6 7    
    1 2 3  4  5  6  7  8     1  0 Â¯1 Â¯2 Â¯3 Â¯4 Â¯5 Â¯6     0 1 2 3 4 5 6 7    
    2 3 4  5  6  7  8  9     2  1  0 Â¯1 Â¯2 Â¯3 Â¯4 Â¯5     0 1 2 3 4 5 6 7    
    3 4 5  6  7  8  9 10     3  2  1  0 Â¯1 Â¯2 Â¯3 Â¯4     0 1 2 3 4 5 6 7    
    4 5 6  7  8  9 10 11     4  3  2  1  0 Â¯1 Â¯2 Â¯3     0 1 2 3 4 5 6 7    
    5 6 7  8  9 10 11 12     5  4  3  2  1  0 Â¯1 Â¯2     0 1 2 3 4 5 6 7    
    6 7 8  9 10 11 12 13     6  5  4  3  2  1  0 Â¯1     0 1 2 3 4 5 6 7    
    7 8 9 10 11 12 13 14     7  6  5  4  3  2  1  0     0 1 2 3 4 5 6 7    
                         â”˜                          â”˜                   â”˜  
                                                                          â”˜
#+end_example


#+BEGIN_EXPORT html
  <div style="text-align: center; font-size: 2em; padding: 20px 0;">
    <a href="#" onclick="goBack(); return false;">âŠ‘âˆ˜âˆ</a>
  </div>
#+END_EXPORT
