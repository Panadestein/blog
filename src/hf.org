# -*- eval: (face-remap-add-relative 'default '(:family "BQN386 Unicode" :height 180)); -*-
#+TITLE: Helonium's Hartree-Fock program
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="assets/style.css"/>
#+HTML_HEAD: <link rel="icon" href="assets/favicon.ico" type="image/x-icon">
#+HTML_HEAD: <style>
#+HTML_HEAD: mjx-container[jax="CHTML"] {
#+HTML_HEAD:   overflow-x: auto !important;
#+HTML_HEAD: }
#+HTML_HEAD: </style>

** Exordium

We will implement the Hartree-Fock[fn:1] program from the classic [[https://store.doverpublications.com/products/9780486691862][Szabo-Ostlund]] text,
a staple in quantum chemistry. If you have any experience in the field, chances are you know it well.
If you don't, the BQN implementation will take you only a few cognitive units: the coarse mathematical
description involves basis sets, the calculation of electronic integrals, and the self-consistent
optimization of the Fock matrix. Using this program, we will compute the energy of the HeH\(^+\) molecule[fn:2].

First, we import the required BQN system values and define some auxiliary functions:

#+begin_src bqn :results none :tangle ./bqn/hf.bqn
  Sinâ€¿Cosâ€¿Tanâ€¿Erf â† â€¢math
  E â† 1eÂ¯6âŠ¸<â—¶(1-Ã·âŸœ3)â€¿((Ï€Ã·4)âŠ¸Ã·Ã—âŸœErfâ—‹âˆšâŠ¢)
#+end_src

Then, we create a namespace with the physical constants defining the system[fn:3],
as is customary in /ab-initio/ methods:

#+begin_src bqn :results none :tangle ./bqn/hf.bqn
  system â† {
    e1â€¿e2 â‡ 2.0925â€¿1.24
    z1â€¿z2 â‡ 2â€¿1
    r â‡ 1.4632 
  }
#+end_src

** STO-3G

Basis sets are used to transform the PDEs into linear algebra problems. Physical intuition suggests that
Slater type orbitals[fn:4] should be a good choice for our Hamiltonian. However, the computation of the integrals
is a lot easier if we approximate them with Gaussian functions[fn:5]. We define the approximating function:

#+begin_src bqn :results none :tangle ./bqn/hf.bqn
  STO â† {
    e â† 0.109818â€¿0.405771â€¿2.22766 Ã—Ã—Ëœ ğ•©
    c â† 0.444635â€¿0.535328â€¿0.154329
    eâ‹ˆcÃ—(2Ã—eÃ·Ï€)â‹†3Ã·4
  }
#+end_src

** Electronic integrals

Constructing the integrals' tensor is complicated[fn:6] and is the main reason for the poor scaling
of electronic structure methods. The \(1s\) orbitals are the simplest case, and here two types of integrals
are analytical (S, T) while the rest already lacks a closed-form solution (V, ERI):

#+begin_src bqn :results none :tangle ./bqn/hf.bqn 
  S â† {aâ€¿bğ•Šğ•©: (1.5â‹†ËœÏ€Ã·a+b) Ã— â‹†-ğ•©Ã—a(Ã—Ã·+)b}
  T â† {aâ€¿bğ•Šğ•©: f â† a(Ã—Ã·+)b â‹„ Ã—Â´âŸ¨1.5â‹†ËœÏ€Ã·a+b, (3Ã—f)-2Ã—ğ•©Ã—Ã—Ëœf, â‹†-ğ•©Ã—fâŸ©}
  V â† {aâ€¿bâ€¿zğ•Šrâ€¿s: Ã—Â´âŸ¨-2Ã—zÃ—Ï€Ã·a+b, E sÃ—a+b, â‹†-rÃ—a(Ã—Ã·+)bâŸ©}
  ERI â† {aâ€¿bâ€¿câ€¿dğ•Šr1â€¿r2â€¿r3â€¿r4:
    r5 â† -Â´âŸ¨aâ€¿b â‹„ câ€¿dâŸ© (+Â´âˆ˜Ã—Ã·+Â´âˆ˜âŠ£)Â¨ âŸ¨r1â€¿r2 â‹„ r3â€¿r4âŸ©
    f1â€¿f2â€¿f3 â† aâ€¿b ({(âˆšâˆ˜+Ã—Ã—)â‹ˆ(Ã—Ã·+)}â—‹(+Â´)âˆ¾<âˆ˜â‹ˆâ—‹((Ã—Ã·+)Â´)) câ€¿d
    Ã—Â´âŸ¨f1Ã·Ëœ2Ã—Ï€â‹†5Ã·2, E f2Ã—Ã—Ëœr5, â‹†-+Â´f3Ã—Ã—Ëœ-Â´Â¨âŸ¨r1â€¿r2, r3â€¿r4âŸ©âŸ©
  }
#+end_src

#+begin_export html
<br/>
<details>
<summary>Derivation strategy</summary>
#+end_export

We need to compute the overlap (S), kinetic energy (T), nuclear attraction (V), and four-center (ERI) integrals.
Crucially, the product of two Gaussians at different centers is proportional to a Gaussian at a scaled center.
This property, combined with the Laplacian of a Gaussian, readily yields S and T. The remaining
two sets are more complex: we combine the Gaussians as before, then transform to reciprocal space where
the delta distribution arises and simplifies the problem to this integration by reduction:

\begin{equation*}
  I(x) = \int_0^{\infty}{{{e^ {- a\,k^2 }\,\sin \left(k\,x\right)}\over{k}}\;dk} \sim \text{Erf}(x)
\end{equation*}

#+begin_export html
</details>
#+end_export

** Fock operator's matrix

The following function constructs the Fock matrix. Extending this code to an arbitrary
number of atoms would imply mapping over a list of coordinates, as opposed to fusing them
in the implementation, as we do here for simplicity.

#+begin_src bqn :tangle :results none ./bqn/hf.bqn
  F â† {ğ•Še1â€¿e2â€¿z1â€¿z2â€¿r:
    bsâ€¿nb â† (âŠ¢â‹ˆâ‰ âˆ˜âŠ‘)â‰>STOÂ¨ e1â€¿e2
    D â† {âˆ¾â€¿Ã—({2: {nb(â‹ˆËœ/âˆ˜â‹ˆËœ)âŠ¸âŠ”ğ•âŒœËœğ•©}; 4: {ğ•âŒœâŸ3Ëœğ•©}}ğ•©)Â¨â—‹âŠ¢<âˆ˜âˆ¾Ë˜bs}

    smâ€¿hcore â† {ağ•Šd:
      mst â† âŒ½âŠ¸â‰âˆ¾âŸœ0Ã—Ëœr
      r1â€¿r2 â† <Ë˜â‰â¼> (râŠ¸-âŠ¸â‹ˆËœÃ—âŸœrÃ·+)âŒœÂ´ âŠbs
      mv â† Ã—Ëœâˆ˜{[0â€¿2,3â€¿1]âŠ({0â€¿ğ•¨Â¨ğ•©}âŸœğ•©Â¨ğ•¨)âˆ¾â‹ˆâŸœâ‰râ‹ˆÂ¨ğ•©}Â´Â¨âŸ¨0â€¿r, r1âŸ©â€¿âŸ¨râ€¿0, r2âŸ©
      (âŠ‘â‹ˆÂ·+Â´1âŠ¸â†“)+Â´âˆ˜â¥ŠÂ¨Â¨ d<âŠ¸Ã— ({ağ•Â¨Â¨mst}Â¨Sâ€¿T) âˆ¾ z1â€¿z2{aâˆ¾âŸœğ•¨âŠ¸VÂ¨Â¨ğ•©}Â¨mv
    }Â´ D 2

    erim â† {ağ•Šd:
      4 {+Ëâˆ˜â¥Šâ‰ğ•¨ (2Ã—â†•ğ•¨)â‰â¼(2â€¿3â¥ŠËœ2Ã—ğ•¨)â¥Šğ•©}(dâŠ¸Ã—âŠ£ERIÂ¨âŠ¢/ËœÂ·<Â¨â‰¢âˆ˜âŠ£Ã·â‰¢âˆ˜âŠ¢)âŸœ{0â€¿râŠËœâš‡1â†•2Â¨â†•=ğ•©} a
    }Â´ D 4
  }
#+end_src

#+begin_export html
<br/>
<details>
<summary>Performance</summary>
#+end_export

The ERIs computation should be the bottleneck: there =Nâ‹†4= of them, in our case 16. The tensors needed are
of shape =6Â¨â†•4=. As we see in the profile bellow, the fact that I have used an array strategy for the ERIs
made their computation more efficient than for the other two center integrals. For the latter, I traded
rank for depth, creating tiled matrices.

#+begin_src bqn :exports both :tangle no
  )profile {ğ•Š: F system}Â¨â†•1e4
#+end_src

#+RESULTS:
#+begin_example
Got 35458 samples
(self-hosted runtime1): 1016 samples
(REPL): 34442 samples:
    61â”‚F â† {ğ•Še1â€¿e2â€¿z1â€¿z2â€¿r:
    54â”‚  bsâ€¿nb â† (âŠ¢â‹ˆâ‰ âˆ˜âŠ‘)â‰>STOÂ¨ e1â€¿e2
  1930â”‚  D â† {âˆ¾â€¿Ã—({2: {nb(â‹ˆËœ/âˆ˜â‹ˆËœ)âŠ¸âŠ”ğ•âŒœËœğ•©}; 4: {ğ•âŒœâŸ3Ëœğ•©}}ğ•©)Â¨â—‹âŠ¢<âˆ˜âˆ¾Ë˜bs}
      â”‚
   144â”‚  smâ€¿hcore â† {ağ•Šd:
   247â”‚    mst â† âŒ½âŠ¸â‰âˆ¾âŸœ0Ã—Ëœr
  3209â”‚    r1â€¿r2 â† <Ë˜â‰â¼> (râŠ¸-âŠ¸â‹ˆËœÃ—âŸœrÃ·+)âŒœÂ´ âŠbs
 15632â”‚    mv â† Ã—Ëœâˆ˜{[0â€¿2,3â€¿1]âŠ({0â€¿ğ•¨Â¨ğ•©}âŸœğ•©Â¨ğ•¨)âˆ¾â‹ˆâŸœâ‰râ‹ˆÂ¨ğ•©}Â´Â¨âŸ¨0â€¿r, r1âŸ©â€¿âŸ¨râ€¿0, r2âŸ©
  6304â”‚    (âŠ‘â‹ˆÂ·+Â´1âŠ¸â†“)+Â´âˆ˜â¥ŠÂ¨Â¨ d<âŠ¸Ã— ({ağ•Â¨Â¨mst}Â¨Sâ€¿T) âˆ¾ z1â€¿z2{aâˆ¾âŸœğ•¨âŠ¸VÂ¨Â¨ğ•©}Â¨mv
  2937â”‚  }Â´ D 2
   762â”‚
  1967â”‚  erim â† {ağ•Šd:
  1192â”‚    4 {+Ëâˆ˜â¥Šâ‰ğ•¨ (2Ã—â†•ğ•¨)â‰â¼(2â€¿3â¥ŠËœ2Ã—ğ•¨)â¥Šğ•©}(dâŠ¸Ã—âŠ£ERIÂ¨âŠ¢/ËœÂ·<Â¨â‰¢âˆ˜âŠ£Ã·â‰¢âˆ˜âŠ¢)âŸœ{0â€¿râŠËœâš‡1â†•2Â¨â†•=ğ•©} a
     3â”‚  }Â´ D 4
      â”‚}
      â”‚F system
#+end_example

#+begin_export html
</details>
#+end_export

#+begin_export html
<br/>
<details>
<summary>Physical context</summary>
#+end_export

The Fock operator is an effective one-electron operator that arises after constrained
minimization of the energy functional:

\begin{equation*}
  \tilde{\mathcal{F}} \left[ \{\psi_i\} \right] = \sum_i h_i +
  \frac{1}{2} \sum_{i,j} (J_{ij} - K_{ij}) - \sum_{i,j} \lambda_{ij}
  \left( \langle \psi_i | \psi_j \rangle - \delta_{ij} \right)
\end{equation*}

where \(h_i\) is the core Hamiltonian matrix and \(J_{ij}, K_{ij}\) are the Coulomb and
exchange components of the ERI matrix. To fully understand the derivation, consider
the variational derivative of this functional with respect to the complex
conjugate of the wave function \(\psi_i^*\):

\begin{align*}
  \lim_{\epsilon \to 0} \frac{\tilde{\mathcal{F}} \left[ \psi_k^* + \epsilon \delta
   \psi_k^* \right] - \tilde{\mathcal{F}} \left[ \psi_k^* \right]}{\epsilon} 
  &= \langle \delta \psi_k | \hat{h} | \psi_k \rangle + \sum_j \left( \langle \delta
   \psi_k \psi_j | \frac{1}{r} | \psi_k \psi_j \rangle - \langle \delta
   \psi_k \psi_j | \frac{1}{r} | \psi_j \psi_k \rangle \right)
   - \sum_j \lambda_{kj} \langle \delta \psi_k | \psi_j \rangle \\
  &= \int \left[ \hat{h} \psi_k(x) + \sum_j
     \left( \psi_k(x) \int \frac{|\psi_j(x')|^2}{|r - r'|} dx'
   - \psi_j(x) \int \frac{\psi_j^*(x') \psi_k(x')}{|r - r'|} dx' \right) \right.
   \left. - \sum_j \lambda_{kj} \psi_j(x) \right] \delta \psi_k^*(x) \, dx.
\end{align*}

As discussed earlier, basis sets are used to discretize the Hartree-Fock problem.
This process results in the  [[https://en.wikipedia.org/wiki/Roothaan_equations][Roothaan equations]], which are implemented in the code above.

#+begin_export html
</details>
#+end_export

** SCF

Compare the electronic energy with the one computed using the original [[./supp/hf_so/hf_so.html][F66]] program.

[fn:1] Recasting of the [[https://en.wikipedia.org/wiki/Schr%C3%B6dinger_equation#Time-independent_equation][TISE]] into a set of coupled integro-differential equations. Derived by optimizing
the expectation value of the energy subject to normalization constraints, then discretizing it using a suitable
basis set.
[fn:2] It may not look like much, but helonium was the very [[https://www.scientificamerican.com/article/the-first-molecule-in-the-universe/][first molecule]] formed in the universe.
[fn:3] This program can compute the Hartree-Fock energy of any two-electron diatomic molecule.
[fn:4] STO: functions of the form \(r^le^{-\zeta r}Y_l^m(\theta, \phi)\). For \(1s\) orbitals the
spherical harmonics integrate out to 1.
[fn:5] STO-nG: a non-linear least-squares fit of an STO as a weighted sum of n Gaussians.
[fn:6] See for example [[https://arxiv.org/abs/2007.12057][arXiv:2007.12057]].

#+BEGIN_EXPORT html
  <div style="text-align: center; font-size: 2em; padding: 20px 0;">
    <a href="https://panadestein.github.io/blog/" style="text-decoration: none;">âŠ‘âˆ˜âˆ</a>
  </div>
#+END_EXPORT
