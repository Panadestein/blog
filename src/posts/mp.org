#+TITLE: Blazing matrix products
#+INCLUDE: "../html-head.org"

** Why not use BLAS?

Because I am interested in Brutalist array programming,
and the absence of a high-performance native matrix product in BQN was
a compelling opportunity for exploration[fn:1].
Of course wrapping =dgemm= is always an option:

#+begin_src bqn :tangle ../bqn/mp.bqn :exports code
  blasFFI â† (âŠ£â€¢FFIÂ·(1-Ëœ+`Ã—Â¬)âˆ˜=âŸœâŠâŠ¸âŠ”âŠ¢)Â´ âŸ¨
    "/lib/libcblas.so"âˆ¾Ëœâ€¢BQN 1âŠ‘â€¢Sh "nix-instantiate"â€¿"--eval-only"â€¿"--expr"â€¿"(import <nixpkgs> {}).blas.outPath"
    " & cblas_dgemm u32 u32 u32 i32 i32 i32 f64 *f64 i32 *f64 i32 f64 &f64 i32"
  âŸ©
  Dgemm â† {BlasFFI 101â€¿111â€¿111â€¿mâ€¿nâ€¿kâ€¿1â€¿ğ•¨â€¿kâ€¿ğ•©â€¿nâ€¿0â€¿(mâ€¿nâ¥Š0)âˆ¾âŠ¢Â´mâ€¿kâ€¿Â·â€¿nâ†ğ•¨âˆ¾â—‹â‰¢ğ•©}
#+end_src

In case you're wondering, this function has roughly the same overhead as NumPy's =dot=.
For fun, let's challenge the idea that you should never write your own[fn:2] GEMM,
but rather wrap BLAS.

** Taming the cache

The first step towards higher performance is employing blocking to optimize cache access patterns.
By using a straightforward square partitioning of the input matrices (without resorting to
specialized assembly kernels and instead relying on the native BQN idiom) speed-ups
of approximately sixfold are achievable for matrices that exceed the machine's cache size:

#+begin_src bqn :tangle ../bqn/mp.bqn :exports both
  matâ€¿mbt â† âŸ¨â‹ˆËœ2â¥Š500, â‹ˆËœ5â¥Š600âŸ© /Â¨âŠ¸âŠ”Â¨ maâ€¿mb â† â€¢rand.RangeâŸœ0Â¨1e3Ã—âŸ¨1â€¿1, 3â€¿3âŸ©
  >âŸ¨maâ€¿maâ€¿mat, mbâ€¿mbâ€¿mbtâŸ© {ğ•Ëœâ€¢_timedğ•©}Â¨Â¨Ëœ <âŸ¨Dgemm, +Ëâˆ˜Ã—â‰1â€¿âˆ, âˆ¾(+Ë+Ëâˆ˜Ã—â‰1â€¿âˆÂ¨)â‰1â€¿âˆâŸ©
#+end_src

#+RESULTS:
: â”Œâ”€                                                            
: â•µ         0.008988871        0.646108393 0.37081367400000004  
:   0.16528436400000002 45.110128999000004   7.460860705000001  
:                                                              â”˜

This performance gain requires only a modest 10-character leap in the code,
from =+Ëâˆ˜Ã—â‰1â€¿âˆ= to =âˆ¾(+Ë+Ëâˆ˜Ã—â‰1â€¿âˆÂ¨)â‰1â€¿âˆ=. Let's abstract this logic into reusable code.
For instance, the function below[fn:3] computes powers of a square matrix =ğ•©= using blocks of size =ğ•¨=,
padding with zeros as needed. This operation is particularly useful in domains like graph theory or
analyzing Markov chains:

#+begin_src bqn :tangle ../bqn/mp.bqn :exports code
  MPB â† {ğ•©â‰¢âŠ¸â†‘âˆ¾(+Ë+Ëâˆ˜Ã—â‰1â€¿âˆÂ¨)â‰1â€¿âˆËœğ•©(â¥ŠâŸœğ•¨Â¨âˆ˜âŠ¢/Â¨âŠ¸âŠ”ğ•¨âŠ¸Ã—â†‘âŠ£)âŒˆğ•¨Ã·Ëœâ‰¢ğ•©}
#+end_src

#+RESULTS:
: (function block)

An empirical (naÃ¯ve, really) search for the optimal block size yields:

#+begin_src bqn :tangle ../bqn/mp.bqn :exports both
  (300+50Ã—â†•8) {ğ•¨âŠ¸MPBâ€¢_timedğ•©}Â¨ <3e3â€¿3e3 â€¢rand.Range 0
#+end_src

#+RESULTS:
: âŸ¨ 8.30279774 10.112563361000001 9.781014477000001 9.670085717000001 7.556631647000001 10.970897867000001 7.570657628 10.231164773000001 âŸ©

One might hypothesize that further performance could be gained by applying this blocking principle
recursively to accommodate multiple levels of cache. This technique, known as nested tiling,
can also be implemented easily, though experimentation shows it yields no improvement:

#+begin_src bqn :tangle ../bqn/mp.bqn :exports both
  MPB2 â† {âˆ¾âˆ¾Ã—_pÂ¨_pÂ¨(_pâ†{+Ëâˆ˜ğ”½â‰1â€¿âˆ})Ëœğ•©{ğ•©âŠ”Ëœ/Â¨â¥ŠâŸœğ•¨Â¨âŒˆğ•¨Ã·Ëœâ‰¢ğ•©}Â´ğ•¨}
  âŸ¨10â€¿60, 4â€¿250, 3â€¿500âŸ© {ğ•¨âŠ¸MPB2â€¢_timedğ•©}Â¨ <3e3â€¿3e3â€¢rand.Range 0
#+end_src

#+RESULTS:
: âŸ¨ 14.096323785000001 9.16644102 7.668334754000001 âŸ©

Having seemingly reached the limits of performance gains by optimizing memory access patterns,
the next logical step is to attack the problem from a different axis: reducing the algorithm's
asymptotic complexity. Here is a little divide-and-conquer (and cache-oblivious) [[https://en.wikipedia.org/wiki/Strassen_algorithm][algorithm]] in its classic
radix-2 form. It works for any square matrix, regardless of dimension: if it is odd,
we pad with an extra row and column, and then take back the original.

#+begin_src bqn :tangle ../bqn/mp.bqn :exports code
  _strassen_ â† {ğ•˜â‰¥â‰ ğ•© ? ğ•¨ğ”½ğ•©;
    [aâ€¿b,câ€¿d]â€¿[eâ€¿f,gâ€¿h] â† (2âŠ¸â¥ŠÂ¨âˆ˜âŠ¢/Â¨âŠ¸âŠ”2âŠ¸Ã—â†‘âŠ£)Â¨âŸœ(âŒˆ2Ã·Ëœâ‰¢Â¨)ğ•¨â€¿ğ•©
    p1â€¿p2â€¿p3â€¿p4â€¿p5â€¿p6â€¿p7 â† ğ•ŠÂ´Â¨âŸ¨a+d,e+hâŸ©â€¿âŸ¨c+d,eâŸ©â€¿âŸ¨a,f-hâŸ©â€¿âŸ¨d,g-eâŸ©â€¿âŸ¨a+b,hâŸ©â€¿âŸ¨c-a,e+fâŸ©â€¿âŸ¨b-d,g+hâŸ©
    ğ•©â‰¢âŠ¸â†‘âˆ¾âŸ¨p1+p4+p7-p5, p3+p5âŸ©â‰âŸ¨p2+p4, p1+p3+p6-p2âŸ©
  }
#+end_src

#+RESULTS:
: (2-modifier block)

Let's go somewhat big for a solid 9x speed-up over the naive implementation:

#+begin_src bqn :tangle ../bqn/mp.bqn :exports both
  âŸ¨+Ëâˆ˜Ã—â‰1â€¿âˆ, 600âŠ¸MPB, +Ëâˆ˜Ã—â‰1â€¿âˆ _strassen_ 256, Dgemm _strassen_ 256, DgemmâŸ© {ğ•Ëœâ€¢_timedğ•©}Â¨ <4096â€¿4096â€¢rand.Range 0
#+end_src

#+RESULTS:
: âŸ¨ 121.21441014300001 23.299975492 13.688074838 2.1399266160000003 0.400549596 âŸ©

To the best of my ability, this marks the limit of what can be achieved with a pure,
single-threaded BQN implementation[fn:4]. 

** Parallelism via MPI

To approach true bare-metal performance on par with BLAS/BLIS, we must leverage multiple cores.
As BQN lacked native support for SPMD programming, I developed bindings for a small
(but useful IMHO) subset of the Message Passing Interface (MPI), which are available on [[https://codeberg.org/panadestein/bqn-mpi][Codeberg]].

With these bindings, I implemented a variant of Cannon's [[https://en.wikipedia.org/wiki/Cannon%27s_algorithm][algorithm]]. In this version, each process
generates its initial local matrices, though scattering and gathering could be added as needed.
The implementation assumes a perfect square number of tasks (otherwise errors out),
forming a processor grid of =â‹ˆËœâˆšp=, and pads matrices whose dimensions are not divisible by =âˆšp=.

#+begin_src bqn :tangle ../bqn/mp.bqn :exports code
  âŸ¨mpiâŸ© â‡ â€¢Import "mpi.bqn"

  mpi.Init@ â‹„ râ€¿s â† mpi{ğ•—.Rankâ‹ˆğ•—.Size}â‹ˆcw â† mpi.comm_world

  # Processor element coordinates in 2D grid (râ‰¡y+qÃ—x)
  !âŒŠâŠ¸=qâ†âˆšs â‹„ b â† qÃ·Ëœn â† 2â‹†12 â‹„ xâ€¿y â† q(|â‹ˆËœÂ·âŒŠÃ·Ëœ)r

  # Local matrices
  aml â† (+Â´bâ€¿bÃ—xâ€¿y)++âŒœËœâ†•b
  bml â† (-Â´bâ€¿bÃ—xâ€¿y)+-âŒœËœâ†•b

  # Toroidal topology with periodic boundary conditions (amlâ†) (bmlâ†‘)
  Lâ€¿U â† {(cwâŠ¸mpi.SendrecvâŠ¢<âŠ¸âˆ¾ğ•©Ë™)âŒ¾â¥Š}Â¨âŸ¨(qÃ—x)+q|y(-â‹ˆ+)1 â‹„ y+qÃ—q|x(-â‹ˆ+)1âŸ©

  # Strassen algorithm with blocking for cache efficiency
  _strassen_ â† {ğ•˜â‰¥â‰ ğ•© ? ğ•¨ğ”½ğ•©;
    [aâ€¿b,câ€¿d]â€¿[eâ€¿f,gâ€¿h] â† (2âŠ¸â¥ŠÂ¨âˆ˜âŠ¢/Â¨âŠ¸âŠ”2âŠ¸Ã—â†‘âŠ£)Â¨âŸœ(âŒˆ2Ã·Ëœâ‰¢Â¨)ğ•¨â€¿ğ•©
    p1â€¿p2â€¿p3â€¿p4â€¿p5â€¿p6â€¿p7 â† ğ•ŠÂ´Â¨âŸ¨a+d,e+hâŸ©â€¿âŸ¨c+d,eâŸ©â€¿âŸ¨a,f-hâŸ©â€¿âŸ¨d,g-eâŸ©â€¿âŸ¨a+b,hâŸ©â€¿âŸ¨c-a,e+fâŸ©â€¿âŸ¨b-d,g+hâŸ©
    ğ•©â‰¢âŠ¸â†‘âˆ¾âŸ¨p1+p4+p7-p5, p3+p5âŸ©â‰âŸ¨p2+p4, p1+p3+p6-p2âŸ©
  }
  MP â† +Ëâˆ˜Ã—â‰1â€¿âˆ _strassen_ 256

  # Skewing
  aml LâŸxâ†© â‹„ bml UâŸyâ†©

  # Multiply and shift
  cml â† +Â´{ğ•Š: amlâŠ¸MPâŸœbmlâŸ¨aml Lâ†© â‹„ bml Uâ†©âŸ©}Â¨â†•q

  # Test (not included in benchmark)
  cmf â† (+âŒœËœ+Ëâˆ˜Ã—â‰1â€¿âˆ-âŒœËœ)â†•n
  !cmlâ‰¡râŠ‘â¥Šcmf/Â¨âŠ¸âŠ”Ëœâ‹ˆËœqâ¥Šb

  mpi.Finalize@
#+end_src

Which yields a speed-up of

#+begin_export html
<details>
<summary>31x</summary>
#+end_export

#+begin_src bash :results raw :wrap example :exports both
  hyperfine --runs 4 'bqn -e "+Ëâˆ˜Ã—â‰1â€¿âˆËœ âŸ¨2â‹†12,2â‹†12âŸ©â€¢rand.Range 1e5"' 'mpirun --mca btl self,sm -n 4 bqn -f cannon.bqn'
#+end_src

#+RESULTS:
#+begin_example
Benchmark 1: bqn -e "+Ëâˆ˜Ã—â‰1â€¿âˆËœ âŸ¨2â‹†12,2â‹†12âŸ©â€¢rand.Range 1e5"
  Time (mean Â± Ïƒ):     108.965 s Â±  1.897 s    [User: 107.824 s, System: 0.169 s]
  Range (min â€¦ max):   106.771 s â€¦ 110.747 s    4 runs
 
Benchmark 2: mpirun --mca btl self,sm -n 4 bqn -f cannon.bqn
  Time (mean Â± Ïƒ):      3.510 s Â±  0.012 s    [User: 11.990 s, System: 0.701 s]
  Range (min â€¦ max):    3.493 s â€¦  3.521 s    4 runs
 
Summary
  mpirun --mca btl self,sm -n 4 bqn -f cannon.bqn ran
   31.04 Â± 0.55 times faster than bqn -e "+Ëâˆ˜Ã—â‰1â€¿âˆËœ âŸ¨2â‹†12,2â‹†12âŸ©â€¢rand.Range 1e5"
#+end_example

#+begin_export html
</details>
#+end_export

This result is only possible thanks to a combination of SPMD parallelism and a
cache-efficient matrix multiplication algorithm. We have improved significantly,
going from =+Ëâˆ˜Ã—â‰1â€¿âˆ= being 300 times slower than OpenBLAS's =dgemm= to only eight times slower.
The obvious limitation of Cannon's algorithm is the need for a perfect square number of tasks.
But if your computer supports SMT, you can push the problem size further with the
option =--use-hwthread-cpus=. Careful with the memory usage, though, as it might bring your system to a crawl
if you push it too far.

[fn:1] While the current idiom guarantees numerical accuracy, it is hundreds of times slower
than BLAS for large matrices.
[fn:2] See this [[https://en.algorithmica.org/hpc/algorithms/matmul/][post]] for a surprisingly accessible way to replicate what OpenBLAS
does without spending your life in assembly.
[fn:3] Here I could have used a fancier but slower under =ğ”½ËœâŒ¾((/Â¨â¥ŠâŸœğ•¨Â¨âŒˆğ•¨Ã·Ëœâ‰¢ğ•©)âŠ¸âŠ”)=. Or even the
memory-hungry outer product formulation =+Ëâ‰âˆ˜âŠ¢(+Ëâˆ˜Ã—â‰1â€¿âˆÂ¨)âŒœË˜âŠ¢=, which is only marginally slower.
[fn:4] For deeper insight into blocked matrix multiplication algorithms, I recommend
this [[https://docs.jax.dev/en/latest/pallas/tpu/matmul.html][JAX post]], the SaC [[https://dl.acm.org/doi/10.1145/3609024.3609410][paper]] on rank polymorphic blocking, and [[https://arxiv.org/abs/1605.01078][arXiv:1605.01078]]
for the high-performance Strassen implementation.

#+INCLUDE: "../html-foot.org"

# Local Variables:
# org-html-htmlize-output-type: nil
# End:
